import { Manifest } from '../manifest'
import { Plugin } from '../types'
import * as Path from 'path'
import State from '../state'

const term = (s: string): string =>
  /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) ? s : "`" + s + "`"

const stringLiteral = (s: string): string =>
  /["\n\r\t\\]/.test(s) ? `"""${s}"""` : `"${s}"`

type ExtractCssArgs = {
  fileFilter     : (_: string) => string
  newManifestName: (_: string) => string
}

export const extractCss: (_: ExtractCssArgs) => Plugin = ({
  fileFilter = f => /\.css$/.test(f),
  newManifestName = n => `${n}Urls`,
}) => state => {

  for (const [manifestKey, manifestValue] of Object.entries(state.manifest.getEntries())) {
    const filename = manifestValue.local
    if (filename && fileFilter(filename)) {
      const op = state.getOpThatCreatesLocalFile(filename)
      if (op) {
        const name = newManifestName(manifestKey)
        const css = State.opContent(op)
        const urls: Array<string> = [];
        (css.match(/url *\( *.+? *\)/g) || []).forEach((s) => {
          if (!/url\(data:/.test(s)) {
            const m = s.match(/url *\( *['"]?(.+?)['"]? *\)$/)
            if (m && m[1])
              urls.push(m[1])
          }
        })
        state.manifest.addList(name, urls)
      }
    }
  }
}

type ScalaArgs = {
  object    : string
  filename  : string
  outputPath: string
  nameMod?  : (_: string) => string
}

const scala: (_: ScalaArgs) => Plugin = args => state => {
  const { object, filename, outputPath, nameMod = n => n } = args

  const fqcn = object.match(/^(.+)\.([^.]+)$/)
  if (!fqcn) {
    state.addError(`Invalid object FQCN: ${object}`)
  } else {

    const manifest = state.manifest
    const [, pkg, obj] = fqcn
    let cdnUsed = false

    const defs = []
    for (const k of Object.keys(manifest.getEntries()).sort()) {
      const v = manifest.getEntries()[k]
      // console.log(`${k} = ${require('../utils').inspect(v)}`)

      const name = nameMod(k)
      const url = Manifest.url(v, false)
      if (v.cdn) {
        cdnUsed = true
        const {url, integrity} = v.cdn
        const i = integrity ? `Some(${stringLiteral(integrity)})` : 'None'
        defs.push(`def ${term(name)} = CDN(\n  href = ${stringLiteral(url)},\n  integrity = ${i})`)
      } else if (url) {
        defs.push(`def ${term(name)} = ${stringLiteral(url)}`)
      } else if (v.list) {
        const vs = v.list.map(i => `\n  ${stringLiteral(i)} ::`).join('')
        defs.push(`def ${term(name)}: List[String] =${vs}\n  Nil`)
      }

      // final case class Resource(url: String, integrity: Option[String])
    }

    const content = [
      `package ${pkg}`,
      "",
      "/** Generated by webtamp. */",
      `object ${obj} {`,
      "",
      cdnUsed && "  final case class CDN(href: String, integrity: Option[String])",
      cdnUsed && "",
      defs.map(l => l.replace(/^/gm, "  ")).join("\n\n"),
      "}"
    ].filter(s => s !== false).join("\n")

    // console.log("-------------------------------------------------------------------------")
    // console.log(content)
    // console.log("-------------------------------------------------------------------------")

    let outfile = filename || `${obj}.scala`
    if (outputPath)
      outfile = Path.join(outputPath, outfile)

    state.addOpWrite(outfile, content)
  }
}

export const generate = { scala }
