import { Manifest } from '../manifest'
import { Plugin } from '../types'
import * as Path from 'path'
import State from '../state'

const term = (s: string): string =>
  /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) ? s : "`" + s + "`"

const stringLiteral = (s: string): string =>
  /["\n\r\t\\]/.test(s) ? `"""${s}"""` : `"${s}"`

type ExtractCssArgs = {
  fileFilter     : (_: string) => string
  newManifestName: (_: string) => string
}

export const extractCss: (_: ExtractCssArgs) => Plugin = ({
  fileFilter = f => /\.css$/.test(f),
  newManifestName = n => `${n}Urls`,
}) => state => {

  for (const [manifestKey, manifestValue] of Object.entries(state.manifest.getEntries())) {
    const filename = manifestValue.local
    if (filename && fileFilter(filename)) {
      const op = state.getOpThatCreatesLocalFile(filename)
      if (op) {
        const name = newManifestName(manifestKey)
        const css = State.opContent(op)
        const urls: Array<string> = [];
        (css.match(/url *\( *.+? *\)/g) || []).forEach((s) => {
          if (!/url\(data:/.test(s)) {
            const m = s.match(/url *\( *['"]?(.+?)['"]? *\)$/)
            if (m && m[1])
              urls.push(m[1])
          }
        })
        state.manifest.addList(name, urls)
      }
    }
  }
}

type ScalaArgs = {
  object    : string
  filename  : string
  outputPath: string
  nameMod?  : (_: string) => string
  abstract? : boolean
}

const scala: (_: ScalaArgs) => Plugin = args => state => {
  const { object, filename, outputPath, abstract, nameMod = n => n } = args

  const modify: (s: String) => String =
    abstract ? s => `modify(${s})` : s => s

  const def: String =
    abstract ? "final val" : "def"

  const fqcn = object.match(/^(.+)\.([^.]+)$/)
  if (!fqcn) {
    state.addError(`Invalid object FQCN: ${object}`)
  } else {

    const manifest = state.manifest
    const [, pkg, obj] = fqcn
    let cdnUsed = false

    const defs = []
    for (const k of Object.keys(manifest.getEntries()).sort()) {
      const v = manifest.getEntries()[k]
      // console.log(`${k} = ${require('../utils').inspect(v)}`)

      const name = nameMod(k)
      const url = Manifest.url(v, false)
      if (v.cdn) {
        cdnUsed = true
        const {url, integrity} = v.cdn
        const i = integrity ? `Some(${stringLiteral(integrity)})` : 'None'
        defs.push(`${def} ${term(name)} = CDN(\n  href = ${stringLiteral(url)},\n  integrity = ${i})`)
      } else if (url) {
        defs.push(`${def} ${term(name)} = ${modify(stringLiteral(url))}`)
      } else if (v.list) {
        const vs = v.list.map(i => `\n  ${modify(stringLiteral(i))} ::`).join('')
        defs.push(`${def} ${term(name)}: List[String] =${vs}\n  Nil`)
      }

      // final case class Resource(url: String, integrity: Option[String])
    }

    const lines: Array<string> = []
    lines.push(`package ${pkg}`)
    lines.push('')
    lines.push("/** Generated by webtamp. */")

    if (abstract) {
      if (cdnUsed) {
        lines.push(`object ${obj} {`)
        lines.push("  final case class CDN(href: String, integrity: Option[String])")
        lines.push("}")
        lines.push("")
      }
      lines.push(`abstract class ${obj}[+A] {`)
      if (cdnUsed) {
        lines.push(`  import ${obj}._`)
        lines.push('')
      }
      lines.push('  protected def modify(f: String): A')
      lines.push('')

    } else {
      // Non-abstract
      lines.push(`object ${obj} {`)
      lines.push("")
      if (cdnUsed) {
        lines.push("  final case class CDN(href: String, integrity: Option[String])")
        lines.push("")
      }
    }

    lines.push(defs.map(l => l.replace(/^/gm, "  ")).join("\n\n"))
    lines.push("}")

    // console.log("-------------------------------------------------------------------------")
    // console.log(content)
    // console.log("-------------------------------------------------------------------------")

    const content = lines.join("\n")

    let outfile = filename || `${obj}.scala`
    if (outputPath)
      outfile = Path.join(outputPath, outfile)

    state.addOpWrite(outfile, content)
  }
}

export const generate = { scala }
